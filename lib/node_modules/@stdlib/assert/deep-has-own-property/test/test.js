'use strict';

// MODULES //

var tape = require( 'tape' );
var deepHasOwnProp = require( './../lib/index.js' );


// TESTS //

tape( 'main export is a function', function test( test ) {
	test.ok( true, __filename );
	test.strictEqual( typeof deepHasOwnProp, 'function', 'export is a function' );
	test.end();
});

tape( 'the function exports a factory function', function test( test ) {
	test.strictEqual( typeof deepHasOwnProp.factory, 'function', 'exports a factory function' );
	test.end();
});

tape( 'the function returns `false` if provided `null` or `non-object` for the first argument', function test( test ) {
	var bool;

	bool = deepHasOwnProp( null, 'a.b.c' );
	test.strictEqual( bool, false, 'returns false when provided null as a first argument' );

	bool = deepHasOwnProp( void 0, 'beep.boop' );
	test.strictEqual( bool, false, 'returns false when provided undefined as a first argument' );

	bool = deepHasOwnProp( NaN, 'foo.bar.baz' );
	test.strictEqual( bool, false, 'returns false when provided NaN as a first argument' );

	bool = deepHasOwnProp( 3, 'a.0.b.0' );
	test.strictEqual( bool, false, 'returns false when provided number as a first argument' );

	bool = deepHasOwnProp( [], 'c.b.a' );
	test.strictEqual( bool, false, 'returns false when provided array as a first argument' );

	test.end();
});

tape( 'the function throws an error if provided a key path argument which is neither a string primitive or a key array', function test( test ) {
	var throwsErr;

	throwsErr = incorrectPathValue( null );
	test.throws( throwsErr, TypeError, 'throws error when provided null as a path' );

	throwsErr = incorrectPathValue( void 0 );
	test.throws( throwsErr, TypeError, 'throws error when provided undefined as a path' );

	throwsErr = incorrectPathValue( NaN );
	test.throws( throwsErr, TypeError, 'throws error when provided NaN as a path' );

	throwsErr = incorrectPathValue( 3 );
	test.throws( throwsErr, TypeError, 'throws error when provided number as a path' );

	throwsErr = incorrectPathValue( {} );
	test.throws( throwsErr, TypeError, 'throws error when provided object as a path' );

	test.end();

	function incorrectPathValue( path ) {
		return function incorrectPathValue() {
			var obj = {
				'a': {
					'b' : 'c'
				}
			};
			deepHasOwnProp( obj, path );
		};
	}
});

tape( 'the function throws an error if provided an options argument which is not an object', function test( test ) {
	var throwsErr;

	throwsErr = incorrectOptionsValue( null );
	test.throws( throwsErr, TypeError, 'throws error when provided null as an option' );

	throwsErr = incorrectOptionsValue( void 0 );
	test.throws( throwsErr, TypeError, 'throws error when provided undefined as an option' );

	throwsErr = incorrectOptionsValue( NaN );
	test.throws( throwsErr, TypeError, 'throws error when provided NaN as an option' );

	throwsErr = incorrectOptionsValue( 3 );
	test.throws( throwsErr, TypeError, 'throws error when provided number as an option' );

	throwsErr = incorrectOptionsValue( [] );
	test.throws( throwsErr, TypeError, 'throws error when provided array as an option' );

	test.end();

	function incorrectOptionsValue( options ) {
		return function incorrectOptionsValue() {
			var obj = {
				'a': {
					'b' : 'c'
				}
			};
			deepHasOwnProp( obj, 'a.b', options );
		};
	}
});

tape( 'the function throws an error if provided a `sep` option argument which is not a string primitive', function test( test ) {
	var throwsErr;

	throwsErr = incorrectSepOptionValue( null );
	test.throws( throwsErr, TypeError, 'throws error when provided null as a sep option' );

	throwsErr = incorrectSepOptionValue( void 0 );
	test.throws( throwsErr, TypeError, 'throws error when provided undefined as a sep option' );

	throwsErr = incorrectSepOptionValue( NaN );
	test.throws( throwsErr, TypeError, 'throws error when provided NaN as a sep option' );

	throwsErr = incorrectSepOptionValue( 3 );
	test.throws( throwsErr, TypeError, 'throws error when provided number as a sep option' );

	throwsErr = incorrectSepOptionValue( [] );
	test.throws( throwsErr, TypeError, 'throws error when provided array as a sep option' );

	test.end();

	function incorrectSepOptionValue( sepValue ) {
		return function incorrectSepOptionValue() {
			var obj = {
				'a': {
					'b' : 'c'
				}
			};
			deepHasOwnProp( obj, 'a.b', {
				'sep': sepValue
			});
		};
	}
});

tape( 'the function returns `true` if an object has a specified path (defined as a delimited string)', function test( test ) {
	var bool;
	var dHasOwn;

	bool = deepHasOwnProp( { 'a': { 'b': { 'c': 'd'} } }, 'a.b.c' );
	test.strictEqual( bool, true, 'returns true' );

	bool = deepHasOwnProp( { 'a': [ {'b': [ { 'c': 'd' }, { 'e': 'f' } ] } ] }, '0.a.0.b.0.c' );
	test.strictEqual( bool, true, 'returns true' );

	dHasOwn = deepHasOwnProp.factory('a.b.0.c');
	bool = deepHasOwnProp( { 'a': { 'b': [ { 'c': 'd'} ] } } );
	test.strictEqual( bool, true, 'returns true' );

	test.end();
});

tape( 'the function returns `true` if an object has a specified path (defined as a key array)', function test( test ) {
	var bool;
	var dHasOwn;

	bool = deepHasOwnProp( { 'a': { 'b': { 'c': 'd'} } }, [ 'a', 'b', 'c' ] );
	test.strictEqual( bool, true, 'returns true' );

	bool = deepHasOwnProp( { 'a': [ {'b': [ { 'c': 'd' }, { 'e': 'f' } ] } ] }, [ '0', 'a', '0', 'b', '0', 'c' ] );
	test.strictEqual( bool, true, 'returns true' );

	dHasOwn = deepHasOwnProp.factory([ 'a', 'b', '0', 'c' ]);
	bool = deepHasOwnProp( { 'a': { 'b': [ { 'c': 'd'} ] } } );
	test.strictEqual( bool, true, 'returns true' );

	test.end();
});

tape( 'the function returns `true` if an object has a specified path (using non-default delimiter)', function test( test ) {
	var bool;
	var dHasOwn;

	bool = deepHasOwnProp( { 'a': { 'b': { 'c': 'd'} } }, 'a/b/c', {
		sep: '/'
	});
	test.strictEqual( bool, true, 'returns true' );

	bool = deepHasOwnProp( { 'a': [ {'b': [ { 'c': 'd' }, { 'e': 'f' } ] } ] }, '0/a/0/b/0/c', {
		sep: '/'
	});
	test.strictEqual( bool, true, 'returns true' );

	dHasOwn = deepHasOwnProp.factory('a/b/0/c', {
		sep: '/'
	});
	bool = deepHasOwnProp( { 'a': { 'b': [ { 'c': 'd'} ] } } );
	test.strictEqual( bool, true, 'returns true' );

	test.end();
});

tape( 'the function returns `false` if an object does not have a specified path (defined as a delimited string)', function test( test ) {
	var bool;
	var dHasOwn;

	bool = deepHasOwnProp( { 'a': { 'b': { 'c': 'd' } } }, 'a.b.c.d.e' );
	test.strictEqual( bool, false, 'returns false' );

	bool = deepHasOwnProp( { 'a': [ {'b': [ { 'c': 'd' }, { 'e': 'f' } ] } ] }, '0.a.0.b.0.e' );
	test.strictEqual( bool, false, 'returns false' );

	dHasOwn = deepHasOwnProp.factory('a.b.c.0.d');
	bool = deepHasOwnProp( { 'a': { 'b': [ { 'c': 'd'} ] } } );
	test.strictEqual( bool, false, 'returns false' );

	test.end();
});

tape( 'the function returns `false` if an object does not have a specified path (defined as a key array)', function test( test ) {
	var bool;
	var dHasOwn;

	bool = deepHasOwnProp( { 'a': { 'b': { 'c': 'd' } } }, [ 'a', 'b', 'c', 'd', 'e' ] );
	test.strictEqual( bool, false, 'returns false' );

	bool = deepHasOwnProp( { 'a': [ {'b': [ { 'c': 'd' }, { 'e': 'f' } ] } ] }, [ '0', 'a', '0', 'b', '0', 'e' ] );
	test.strictEqual( bool, false, 'returns false' );

	dHasOwn = deepHasOwnProp.factory([ 'a', 'b', 'c', '0', 'd' ]);
	bool = deepHasOwnProp( { 'a': { 'b': [ { 'c': 'd'} ] } } );
	test.strictEqual( bool, false, 'returns false' );

	test.end();
});

tape( 'the function returns `false` if an object does not have a specified path (using non-default delimiter)', function test( test ) {
	var bool;
	var dHasOwn;

	bool = deepHasOwnProp( { 'a': { 'b': { 'c': 'd' } } }, 'a/b/c/d/e', {
		sep: '/'
	});
	test.strictEqual( bool, false, 'returns false' );

	bool = deepHasOwnProp( { 'a': [ {'b': [ { 'c': 'd' }, { 'e': 'f' } ] } ] }, '0/a/0/b/0/e', {
		sep: '/'
	});
	test.strictEqual( bool, false, 'returns false' );

	dHasOwn = deepHasOwnProp.factory('a/b/c/0/d', {
		sep: '/'
	});
	bool = deepHasOwnProp( { 'a': { 'b': [ { 'c': 'd'} ] } } );
	test.strictEqual( bool, false, 'returns false' );

	test.end();
});
